# file scalene/scalene_profiler.py:581-604
# lines [581, 582, 585, 586, 587, 588, 590, 591, 592, 593, 594, 595, 597, 599, 600, 601, 602, 603]
# branches ['585->586', '585->588', '590->597', '590->599', '599->600', '599->601']

import os
import signal
import sys
import pytest
from scalene.scalene_profiler import Scalene

# Assuming the Scalene class is defined as shown in the snippet above
# and that it has the necessary static methods and attributes.


@pytest.fixture
def scalene_cleanup():
    # Fixture to clean up any state after tests
    yield
    # Reset signal handlers to default
    for sig in Scalene.__signals.get_all_signals():
        signal.signal(sig, signal.SIG_DFL)


@pytest.mark.skipif(
    sys.platform != "win32", reason="Test only applicable to win32 platform"
)
def test_enable_signals_win32(scalene_cleanup):
    # Mock the necessary static methods and attributes
    Scalene.__signals = type(
        "Signals",
        (),
        {
            "malloc_signal": signal.SIGINT,
            "free_signal": signal.SIGINT,
            "memcpy_signal": signal.SIGINT,
            "cpu_signal": signal.SIGINT,
            "cpu_timer_signal": signal.ITIMER_REAL,
            "get_all_signals": staticmethod(lambda: [signal.SIGINT]),
        },
    )
    Scalene.__args = type("Args", (), {"cpu_sampling_rate": 0.01})
    Scalene.__orig_signal = staticmethod(signal.signal)
    Scalene.__orig_siginterrupt = staticmethod(signal.siginterrupt)
    Scalene.__orig_setitimer = staticmethod(signal.setitimer)

    # Mock the enable_signals_win32 method
    Scalene.enable_signals_win32 = staticmethod(lambda: None)

    # Call the method under test
    Scalene.enable_signals()

    # Assertions to verify postconditions
    # Since enable_signals_win32 is mocked to do nothing, there's no change in state
    # to assert. In a real test, you would replace the mock with assertions on the
    # expected changes in signal handlers.
    assert Scalene.enable_signals_win32.called
